{"meta":{"title":"acnoo","subtitle":"","description":"","author":"acnoo","url":"https://floribunda1.github.io","root":"/"},"pages":[{"title":"关于我","date":"2022-03-19T14:38:37.000Z","updated":"2022-05-17T09:58:41.270Z","comments":false,"path":"about/index.html","permalink":"https://floribunda1.github.io/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445introduction: name: acnoo born_in: 1999.1 tags: - 非科班码农 - 热爱技术 - 热爱生活 - 死肥宅 - 喜欢打游戏 - 好奇心旺盛 - 社恐患者skills: - css/sass/less - javascript/typescript - vue2/3 - vite/webpack/rollup - giteducation: school: 西北农林科技大学(本科) major_in: 风景园林 graduation_date: 2020 skills: - CET-4 - CET-6working_experience: company: 预策科技(2021.6-?) tags: - bi 产品前端开发 - 地理可视化 company: 同花顺(2020.7-2021.2) tags: - 可视化前端开发 - 啥活都干（前端,后端,可视化）contact_me: wechat: Floribunda1 email: horolls@outlook.com phone: 15129070799one_more: - 欢迎志同道合的人和我一起相互交流成长"},{"title":"MySQL CheatSheet","date":"2022-04-27T06:32:33.985Z","updated":"2021-11-22T02:28:41.413Z","comments":false,"path":"drafts/MySQL CheatSheet.html","permalink":"https://floribunda1.github.io/drafts/MySQL%20CheatSheet.html","excerpt":"登录 1$ mysql --host=localhost --user=xx --password 数据库 1234567SHOW DATABASES; # 显示所有数据库CREATE DATABASE IF NOT EXISTS database_name; # 创建数据库DROP DATABASE IF EXISTS database_name; # 删除数据库USE DATABASE database_name; # 使用数据库","text":"登录 1$ mysql --host=localhost --user=xx --password 数据库 1234567SHOW DATABASES; # 显示所有数据库CREATE DATABASE IF NOT EXISTS database_name; # 创建数据库DROP DATABASE IF EXISTS database_name; # 删除数据库USE DATABASE database_name; # 使用数据库 表 1234567891011121314151617181920212223242526# 展示所有的表SHOW TABLES;# 删除表DROP TABLE table_1, tabel_2;# 创建表CREATE TABLE IF NOT EXISTS table_name ( field_name VARCHAR(100), field_name2 INT, field_name3 ENUM(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)) COMMENT &#x27;这是表的注释&#x27;;# 查看表结构DESCRIBE table_name;DESC table_name;EXPLAIN table_name;SHOW COLUMNS FROM table_name;SHOW FIELDS FROM table_name;# 看表的 ascii 图SHOW CREATE TABLE table_name;# 从某个数据库看某张表SHOW TABLES FROM database_name;# orSHOW TABLE database_name.table_name; 修改表名称 1234# 修改表名称ALTER TABLE old_name RENAME TO new_name;# orRENAME TABLE xxx TO xx, yyy TO yy; 增加列 123456# 向表中添加一列ALTER TABLE table_name ADD COLUMN column_name CHAR(4);# 添加到第一列ALTER TABLE table_name ADD COLUMN column_name CHAR(4) FIRST;# 添加到某一列后面ALTER TABLE table_name ADD COLUMN column_name CHAR(4) AFTER some_column; 删除列 1ALTER TABLE table_name DROP COLUMN column_name; 修改列 123456# 修改列ALTER TABLE table_name MODIFY column_name VARCHAR(20);# 将一个列改为另一个列ALTER TABLE table_name CHANGE old_name new_name VARCHAR(20);# 修改列的位置，可以将 FIRST 替换为 AFTER xxALTER TABLE table_name MODIFY column_name VARCHAR(20) FIRST; 列的属性 123456# 格式为 列名 + 数据格式 + 属性# 默认值column1 VARCHAR(100) DEFAULT &#x27;aa&#x27; # 不设置默认值就相当于 DEFAULT NULL# 非空NOT NULL 主键 1column1 INT PRIMARY KEY UNIQUE 1234567891011121314# 不允许重复column1 VARCHAR(100) UNIQUE# 约束的另一种格式 UNIQUE KEY [约束名] (column1, column2....)CREATE TABLE student_info ( number INT PRIMARY KEY, name VARCHAR(5), sex ENUM(&#x27;男&#x27;, &#x27;女&#x27;), id_number CHAR(18), department VARCHAR(30), major VARCHAR(30), enrollment_time DATE, UNIQUE KEY uk_id_number (id_number)); 外键"},{"title":"MySQL 碎片知识","date":"2022-04-10T14:55:32.342Z","updated":"2021-11-22T02:38:12.329Z","comments":false,"path":"drafts/mysql 零碎知识.html","permalink":"https://floribunda1.github.io/drafts/mysql%20%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86.html","excerpt":"","text":"外键 先看看官方 wiki 是怎么解释外键的 A foreign key is a set of attributes in a table that refers to the primary key of another table. The foreign key links these two tables. 假设有客户表 id user_name user_email age 1 甲 foo@xx.com 21 2 乙 bar@xx.com 37 3 丙 baz@xx.com 32 一个订单表 order_id order_customer create_time 100 1 xx 200 1 xx 300 2 xx"},{"title":"vue-grid-layout 原理简记","date":"2022-04-10T14:55:32.344Z","updated":"2021-11-29T02:42:04.333Z","comments":false,"path":"drafts/vue-grid-layout 原理简记.html","permalink":"https://floribunda1.github.io/drafts/vue-grid-layout%20%E5%8E%9F%E7%90%86%E7%AE%80%E8%AE%B0.html","excerpt":"","text":"这里简单记录一下 grid-layout 的原理 先想想怎么探究 给一组数据，是怎么排序的？ layout: 12345678validateLayout(this.layout) 如果 prop 有问题就直接抛出错误// 如果是 compact 模式，就执行 compactonWindowResize -&gt; 初始化initResponsiveFeatures -&gt; 清除所有的响应式 layouts ?compactLayout -&gt; 压缩一下布局 我发现从 0 开始一点点看初始化流程实在是太费劲了，于是想看看 drag 的时候是怎么处理的 drag 的时候有一个 placeholder 占位，每次在拖动的时候都会重新计算位置 拖动元素时，会根据鼠标位置以及拖拽的信息计算出来它将移动到哪里，然后用占位的 item 代替正在拖拽的 item 整体重新进行排序 拖动的时候，当前的元素记录 dragging position 每次在拖动的时候 GridItem 负责计算新的落点位置 GridLayout 负责重排所有的元素 GridItem 根据当前位置计算出来在 grid 中的位置，然后 GridLayout 负责清洗不正确的数据（比如说有 static 的数据，或者什么的，重新计算一个） GridLayout 处理步骤 真他娘的怪，它怎么知道移动到 1,5 了？我一直没找到修改 layout 的地方 我发现 thoughtspot 的想法和我一模一样，每次移动以后都重新排列后面卡片的顺序 但是这就导致了一个问题，人家的 x,y,w,h 压根就没有用，唯一能用的就是 order 还不是用贪心算法做的，剩下的用的是动态规划，将卡片添加到合适的位置 感觉需要两者做一个结合，或者说允许做调整算法（这里的核心机制我自己要控制一下） 最后确定方案，不用x,y 这种绝对定位做，唯一能控制位置的只有顺序和尺寸，然后顺序的编排采用两种算法：贪心和动态规划 我感觉我要崩溃了，我到现在还没摸清楚这个布局到底怎么计算出来落点的位置的 传入 moveElement 里面的是 draggingElement 的x和y 我猜可能是根据这个 x，y 然后计算碰撞的图形 感觉要将这里换成顺序调换应该就可以了，但是我感觉好他娘的紧张，可能要搞不完了 救命啊啊啊啊啊，我怎么知道用户要拽到哪里去？或者说落点到底怎么确定啊 感觉还是 typora 给人的感觉最舒服。。 应该问题是我跟卡片碰撞时并不知道往前还是往后插？"},{"title":"一个迷茫的人的自述","date":"2022-03-23T04:30:19.508Z","updated":"2022-03-23T02:08:27.581Z","comments":false,"path":"drafts/冲出迷茫.html","permalink":"https://floribunda1.github.io/drafts/%E5%86%B2%E5%87%BA%E8%BF%B7%E8%8C%AB.html","excerpt":"","text":"每个人的人生都像是在一条看不到尽头的道路上前进 胆大的人为自己争取到了更多机会，在他们的身上我看到了积极和浇不灭的热情（为什么会联想到这里？） 是因为我自己的胆子小吗？我也不知道 自己站在人生的道路上，眼前是一堵又一堵的墙，而我在往前进的路上，不得不一次一次的向前撞击，每一次的撞击，墙壁都会出现一些裂缝，自己也会落得头破血流。每一次想尝试往前走时，发现这个怪物一直就在你的眼前，由于心中的害怕和 感觉思绪就像一个乱七八糟的线团相互缠绕在一起，我需要去打开一个又一个的结 想闭着眼睛往前进，却发现自己在走的时候忍不住睁开眼睛，又被怪物吓退回去了，就这样不停的在这里来回徘徊 我学的越多，我自己的选择就越多，所以我才发现了，闭着眼睛往前走（学习）并不能解决我害怕虚拟的怪物的事实 我不知道该怎么办 上面是分割线 我仔细想想我现在能做的选择： 继续补科班基础 把《编码》的博客写上 继续去学 csapp 做自己想做的项目 mind-flow code-to-flow 去钻研可视化 open-gl(webgl) 去卷（根据面试要求去补短板） 把之前的博客补上 刷算法 看源码，手写轮子 感觉越想越迷茫, what to do now? 为什么会有这么多的选择 &amp;&amp; 为什么我会纠结于这其中的每一个？ 我为什么需要做选择？ 想有钱，想快乐，想安稳的度过一辈子 难怪说穷人很难翻身，穷人注定着短视 已经两年工作经验了我，但是我现在还是那么平庸"},{"title":"瀑布流卡片实现","date":"2022-04-10T14:55:32.346Z","updated":"2021-11-22T15:14:04.796Z","comments":false,"path":"drafts/瀑布流卡片实现.html","permalink":"https://floribunda1.github.io/drafts/%E7%80%91%E5%B8%83%E6%B5%81%E5%8D%A1%E7%89%87%E5%AE%9E%E7%8E%B0.html","excerpt":"","text":"最近，公司有一个需求要做瀑布流式卡片，因此在这里简单记录一下自己的思路 其实对于布局来说，最需要关注的就是以下问题 当往仪表盘添加卡片时，卡片应该放在哪里？ 当拖动仪表盘的卡片到特定位置时，卡片的位置会怎么变化？ 当卡片 resize 以后，该怎么排列？ 我觉得要先明确需求：是不是要所有东西都算法搞定？ 肯定不行，一定要留人可以调整的余地 所以我觉得正确的解法应该是这样： 人可以调整，然后人调整的位置就直接记下来（但是两栏的和六栏的不兼容怎么办？） 现在想到的几个问题 人工干预了卡片的位置以后数据结构该怎么表示？ 移动端（两栏布局）和桌面端（六栏布局）的绝对位置该怎么兼容？ 感觉还是要用绝对位置做布局，要不然我感觉做不下去 因为如果不记录绝对位置的话，相当于用户只能调整卡片顺序，无法调整卡片的位置 那要这么说的话感觉这次对于服务端来说更新不会太大（可能对于前端来说改动也不会太大） 假如按照现有的来 1234567interface CardPosition &#123; x: number; y: number; size: string; // w: number; // h: number;&#125; 可以开放一键整理功能(笑 不能逃避问题，不能想着依赖他们，唯一的依据只有道理，所以不要想那么多，做自己觉得最正确的事情，而不是等别人的答案 如果 resize 以后 x,y 是否要同步发生变化？ 是否要见缝插针排？我自己要考虑到所有情况（要去调研竞品） 整理一下仪表盘的可能排列的边界情况 最右侧的卡片 resize 以后把其他卡片挤走了 我刚刚突然想到 我想列举这些边界情况其实是想做归类整理，试图发现其中的规律 但是这些边界情况可能是无穷无尽的，我很难穷举用户到底想做什么 不管最后是什么方式，都是在算法抉择过程中的某一种策略，我可能影响了某一个原因的权重就会改变最后排列的走向 但是如果我采用从上往下的策略，我又会觉得无从入手，所以正确的做法到底是什么？ 先想想自己想达到什么目的？ 贪心算法，寻找最优解的过程 寻找最优解的策略：寻找 y 最小，并能容得下该卡片位置的地方 在 resize 或者 drag 改变位置以后，后面所有的卡片进行重排列 在添加卡片时，将卡片放到最后，并能容得下该卡片位置的地方 所以有卡片顺序这一概念吗？ 如果卡片有 group 这一概念（即用户有意的使用排列的方式将卡片进行分组），那么该不该去破坏用户的组？ 所以是不是有可能会有多个卡片拖拽的功能？但是好像解决不了卡片分组的问题（或者说这个需求本身就可能是一个伪需求） 如果不想破坏原来的组，想一想使用场景 一个人小心翼翼的将某一卡片放置在一个空位，防止其他的卡片被挤走 或者还有一个办法，那就是影响有限，如果真的要折行，不去影响后面的行，只去影响当前行的排列，然后将后面的行整体往下挪（但是我觉得不太理想） 不想那么多，最合理的方案就是使用 贪心算法 寻求局部最优解！"},{"title":"公司项目的微前端迁移","date":"2022-04-10T14:55:32.345Z","updated":"2021-11-22T07:24:01.142Z","comments":false,"path":"drafts/魔方的微前端迁移.html","permalink":"https://floribunda1.github.io/drafts/%E9%AD%94%E6%96%B9%E7%9A%84%E5%BE%AE%E5%89%8D%E7%AB%AF%E8%BF%81%E7%A7%BB.html","excerpt":"","text":"背景介绍： TODO 一些参考资料： 1https://zhuanlan.zhihu.com/p/78362028 微前端是啥？ js entry 和 html entry 看完了 qiankun 以及微前端的简介，还是有点迷迷糊糊的 微前端是个啥？ 微前端的应用场景就是：啥时候可以用 iframe，啥时候就能用微前端！ 但是有一点：一个路由下不能同时有多个微前端应用，因为基座应用是靠路由分发到各个子应用的 iframe 有一个入口是 index.html，就是将一个 html 嵌入到一个页面去"},{"title":"","date":"2022-03-24T13:29:43.798Z","updated":"2022-03-24T13:29:43.798Z","comments":false,"path":"drafts/c/tips.html","permalink":"https://floribunda1.github.io/drafts/c/tips.html","excerpt":"","text":"这里记录一些学 c 的时候零碎的知识点 为什么 free 需要额外释放 string? 不需要释放 int? 123456typedef struct &#123; char *name; int age; int height; int height;&#125; Person; 因为这里的 int 实际上是把值存到了 struct 的那段内存里，而不是存的引用，但是对于 name 来说，实际上存的是地址，所以需要额外把这里的 name 内存给释放掉 纠正：string 也不需要 free，只有 malloc 的才需要被 free gcc 的一些参数(即 makefile CFLAGS) -Wall 在编译过程中输出 warning 信息 -g 生成 debug 信息，用来给 gdb 用 Makefile CFLAGS 是 makefile 里的 implicit rule，用来给 c compiler 传参数 一般可以在 makefile 里加上 clean 命令用来清除生成的产物 12clean: rm -f output gdb 怎么用 一般我们在编译输出产物的时候带上 -g 表示输出 debug 信息 然后我们使用 gdb ./output 表示使用 gdb 打开文件 然后就可以 run 了 12# 跑一遍程序，然后把报错信息和调用栈抛出来gdb --batch --ex r --ex bt --ex q --args"},{"title":"学 C 有感","date":"2022-05-18T15:39:12.627Z","updated":"2022-05-17T02:55:13.910Z","comments":false,"path":"drafts/c/学C有感.html","permalink":"https://floribunda1.github.io/drafts/c/%E5%AD%A6C%E6%9C%89%E6%84%9F.html","excerpt":"","text":"由于最近在看 csapp，所以不可避免的需要去学习一下 C 语言。在谷歌怎么去学 C 以后，发现大家给的答案不外乎就是推荐 C 语言的一些书，比如《C Primer Plus》，《C 和指针》这种的。 看这些砖头一样的书虽然对于编程小白比较友好，但是对于有过一门或者几门编程经验的人来说，未免有些太枯燥冗余了，而且就算把这些书耐心看完，可能最后的效果也不好。 于是在网上搜了一圈没有找到其他的适合的答案以后，便决定自己去动脑思考一下：该怎么去快速上手一门新的语言？ 要回答这个问题，首先就得搞清楚我们需要关注什么 TODO: 这里要想想怎么把这个思路串起来 对于任何一门语言来说，我们的目的都是要用这门语言编写程序来解决某些问题。 我们要关注的有三个方面： C 语言本身语法以及库的 api 基于 C 的项目工程化知识 目标平台（即操作系统）的了解 第一个比较好理解，我们要用一个工具，就一定要知道这个工具怎么用的，就像一个大工具箱，我们要在不同的场景里拿出对应的工具来解决问题 由于我们写的代码最后都是交给操作系统去跑我们的？就像 js 最后的执行都会交给浏览器，所以我们要对浏览器足够熟悉，知道我们的代码是怎么被运行的，这样我们才能尽量少的踩到一些坑里 可能工程化的知识最容易被人忽略，但是在实际的项目里却极为重要，它涉及到很多东西，比如 怎么把别人造的轮子拿过来用 怎么去高效的 debug 我们的代码 如何通过编译配置来适应不同的目标平台 代码的格式化以及 lint 怎么做 能否通过一套固定的流水线来减少我们的重复工作 怎么和他人共同协作项目 单元测试怎么搭建，怎么写 ... 我们对于这些知识的积累大部分来自于工作中的前辈的指导以及自己踩坑的过程中的积累，很难在语言的教学书里找到对应的介绍。上面的这些知识也是来源于我在做前端项目里的一些经验积累，因为我已经有过对应的实践，所以自然知道要做这些事情 当然一口吃不成一个胖子，我们在刚开始学语言的时候，无需关注过多的工程上的知识，我们最好掌握一些对于我们在学习过程中有用的知识，对应到 C 语言里，就显而易见 makefile 的基本知识，如何编译我们的代码 debugger 的使用 其他的如 格式化、lint 等就交给 IDE 再回到刚开始，我学 C 的目的就是为了学 csapp，因此计算机系统的知识无需在学 C 语言的时候过多关注，那剩下的就是熟悉 C 的语法、库以及 makefile、debugger 的使用了 明确了目标便可以开始动手了，加油！"},{"title":"","date":"2022-05-18T15:42:11.597Z","updated":"2022-05-18T15:42:11.597Z","comments":false,"path":"drafts/TODOS.html","permalink":"https://floribunda1.github.io/drafts/TODOS.html","excerpt":"","text":"关于选择和前进的平衡"}],"posts":[{"title":"Dive into Transformation（一）","slug":"dive into transformation(1)","date":"2022-05-09T13:22:14.981Z","updated":"2022-05-18T15:40:31.384Z","comments":true,"path":"2022/05/09/dive into transformation(1)/","link":"","permalink":"https://floribunda1.github.io/2022/05/09/dive%20into%20transformation(1)/","excerpt":"","text":"前言 最近在做的一个项目，其中需要缩放、平移画布的功能，和我们经常使用的 Excalidraw 和 draw.io 的画布平移功能类似，如下图所示： 由于我使用的是 svg 去做渲染，很容易想到用 transform 去实现画布的平移缩放 我们在平时的常规 UI 开发中也会有需要使用 transform 功能的场景，但是大多都是简单的变换位置，比如使用 rotation 去做动画，或者 translation 去调整元素的位置，稍微高级一些的可能会用到 skew, rotation, translation 的组合来做一些更酷炫的 css3 动画 本以为这是个比较简单的功能，但是稍微了解了一下以后发现里面的水比我想象的深，其中困扰我的有但不仅仅限于以下几个问题： transform 的顺序有关系吗?，比如先 scale 再 skew，或先 translate 再 scale transform 的 matrix 属性是什么意思？ 如何以鼠标的位置为 transform-origin 对画布进行平移缩放？ 如何将鼠标的位置根据画布的 transform 转换到画布上的点？比如画布缩放、平移以后在画布上绘制圆和矩形，如何正确的对应到画布的点上？ 这些问题困扰着我，让我感觉它仿佛并不简单，在网上查阅一些资料以后，发现这些问题对应着图形学中的 坐标变换 相关知识，想要深入了解和理解这些又不得不接触线性代数，一个接着一个的坑 🥲 本文更多的是自己对于这部分知识的整理和输出，并不一定都是对的，如有错误欢迎指出 从一些基础的线性代数概念开始 [!note] 以下标 * 的标题表示拓展 对于线性代数和矩阵变换我了解的并不太多，很多稍微高级一点的概念因为现阶段用不到只是蜻蜓点水的过了一遍，比如行列式(determinant) 和 特征值/特征向量(eigenvalues/eigenvectors)等，更多的还是聚焦于向量的表示/变换和矩阵的复合等 这里推荐 3blue1brown 的 Essence of linear algebra - YouTube，讲的很通俗易懂，我自己的大部分对于线代的理解也来源于这个系列，有条件的同学强烈建议去看一看该教程（线代大佬可以无视 🤣） 注：不要偷懒，一定要看看线性代数相关教程 向量 在一些其他编程语言，如 C++ 中，就有一种数据类型为 vector，它表示为一个可以动态扩容的数组，而数组的特点就是 有向的列表。我们在这里要说的向量和 有向的列表 有一定的关联，但又不完全一样 我们可以理解为向量就是 空间中的有向箭头，一个向量由其长度和方向决定，和它在空间中的位置无关，只要两个向长度和方向相同，我们就可以认为它们是同一个向量 例如下图中的 \\(\\vec{AE}\\) 和 \\(\\vec{CD}\\) 就是同一个向量 因此，我们可以认为所有的向量的起点都是原点，也方便我们去研究和理解问题 向量的运算 向量乘以常量 一个向量 \\(\\vec{u}\\) 乘以一个常量 \\(\\lambda\\) 如果 \\(\\lambda &gt; 0\\), 那么结果向量 \\(\\vec{v}\\) 的方向和向量 \\(\\hat{u}\\) 的方向相同，不过长度变为原来的 \\(\\lambda\\) 倍 如果 \\(\\lambda &lt; 0\\)，那么结果向量 \\(\\vec{v}\\) 的方向和向量 \\(\\hat{u}\\) 的方向相反，长度变为原来的 \\(|\\lambda|\\) 倍 如果 \\(\\lambda = 0\\)，那么结果就是 \\(\\vec{0}\\) 向量加减运算 向量的加法可以用两种方式去理解，例如下面的 \\(\\vec{AB} + \\vec{AC}\\) 第一就是平行四边形，即结果等于以 AB AC 为边所组成的平行四边形的对角线 \\(\\vec{AD}\\) 第二就是将一个向量的尾部平移至另一个向量的头部，然后连接第一个向量的尾部和第二个向量的头部，就是两个向量的加和，即 \\(\\vec{AD}\\) 这种运算也有其物理意义，我们可以认为向量代表着空间上的位移，两个向量相加所得到的向量就是实际位移的长度 向量的减法也比较简单，例如 \\(\\vec{AB} - \\vec{AC}\\)，我们可以理解为 \\(\\vec{AB} + (- \\vec{AC})\\) 关于向量的点乘和叉乘这里就不过多描述，后面会提到 向量的线性组合，基向量 在上面也提到，\\(\\vec{AD} = \\vec{AB} + \\vec{AC}\\)，即该向量可以由 线性不相关(linearly independent) 的 \\(\\vec{AB}\\) 和 \\(\\vec{AC}\\) 组合而成，这种一个向量由两个或多个向量的组合表示的现象，被称为 线性组合(linear combination)，用数学公式表达的话，即 \\[ \\begin{align} \\vec{u} = \\alpha \\vec{v} + \\beta \\vec{w}, \\space \\space \\alpha, \\beta \\in R \\end{align} \\] 注： 一组向量线性不相关表示该组向量中的任何一个向量都不能由该组中的其他的向量组合表示 既然向量可以通过线性组合的方式来表示，那我们不妨建立一个二维坐标系，在空间中我们定义两个向量，然后在这个二维坐标系中的任何向量都可以用这两个向量线性组合表示： \\[ \\begin{align} \\hat{i} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} \\\\ \\hat{j} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} \\end{align} \\] 其中 \\(\\hat{i}\\) 表示起点在 (0,0)，终点在 (1, 0) 的向量，\\(\\hat{j}\\) 表示起点在 (0,0)，终点在 (0, 1) 的向量，这两个向量我们称其为 基向量(basis vector) 例如下图中的几个向量，我们都可以用这两个基向量的组合来表示 \\[ \\begin{align} \\vec{AB} &amp;= 2\\vec{i} + 2\\vec{j} \\\\ \\vec{AE} &amp;= \\vec{i} - \\vec{j} \\\\ \\vec{CD} &amp;= 2\\vec{i} - 2\\vec{j} \\end{align} \\] 由 \\(\\{\\vec{i},\\space\\space \\vec{j}\\}\\) 这两个向量线性组合所得到的所有的向量（即整个平面）的空间被称为这一组向量所张成的空间(span) 既然我们已经约定俗成了这两个基向量，那么向量的表示就可以不用那么繁琐，直接省略 \\(\\hat{i}\\) 和 \\(\\hat{j}\\) 了，即 \\[ \\begin{align} \\vec{AB} &amp;= \\begin{bmatrix} 2 \\\\ 2 \\end{bmatrix} \\\\ \\vec{AE} &amp;= \\begin{bmatrix} 1 \\\\ -1 \\end{bmatrix} \\\\ \\vec{CD} &amp;= \\begin{bmatrix} 2 \\\\ -2 \\end{bmatrix} \\end{align} \\] 线性变换 wiki 对于线性变换的定义如下： a linear map (also called a linear mapping, linear transformation, vector space homomorphism, or in some contexts linear function) is a mapping between \\(V \\rightarrow W\\) between two vector spaces that preserves the operations of vector addition and scalar multiplication. 翻译过来，线性变换就是从向量空间 \\(V\\) 到向量空间 \\(W\\) 的映射函数，同时保留向量的加法和标量乘法，这里有几个关键字： 向量空间 即包含一组向量的集合，例如下面的向量空间 \\(V\\)，就表示一个三维空间的所有向量 \\[ \\begin{align} V &amp;= \\{v_1, ..., v_n\\} \\\\ v &amp;= \\{x,\\space y,\\space z\\}, \\space \\space x,y,z \\in R \\end{align} \\] 映射函数， 这表示线性变换的本质就是一个函数，和我们在编程中的函数一样，都是接受一个 input，返回一个 output，这里的 input 和 output 都是向量空间中的成员，即向量 到这里，我们可以暂时的将线性变换理解为：线性变换是一个函数，它的输入是一个向量，输出也是一个向量 但是判断一个变换是否为线性变换，也需要满足两个条件： 所有的直线变换后必须还是直线，不能被弯曲 原点必须保持在原位 从上面两点我们也可以得出一个结论：变换后的网格仍然保持平行等距的特性 例如下面这张图中，就是我们常见的缩放的线性变换，向量 \\(\\vec{v}\\) 从 \\([50, 150]\\) 变换到 \\([100, 300]\\) 的位置 那么有一个问题，我们该如何表示线性变换函数？ 我们在上面提到一个向量可以由一组线性不相关的基向量线性组合得到，同时也约定俗成了笛卡尔坐标系下的基向量 \\[ \\begin{align} \\hat{i} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} \\\\ \\hat{j} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} \\end{align} \\] 而且我们从线性变换中推导出来的结论 -- 即 网格线 仍保持平行等距，我们可以得出另一个结论，即 变换后的向量线性组合不发生变化，例如： \\[ \\vec{v} = 3\\vec{i} + 2\\vec{j} \\] 那么在经过线性变换以后，我们可以得到 \\[ \\vec{v&#39;} = 3 \\vec{i&#39;} + 2\\vec{j&#39;} \\] [!IMPORTANT] 我们可以用经过线性变换后的基向量来表示一次线性变换，然后所有的向量都可以由这一组向量线性组合得到 例如我们在上图中的 gif 图中，可以看出是将所有的向量执行了 scale 操作，其基向量变换后的值为 \\[ \\begin{align} \\vec{i} = \\begin{bmatrix} 2 \\\\ 0 \\end{bmatrix} \\\\ \\vec{j} = \\begin{bmatrix} 0 \\\\ 2 \\end{bmatrix} \\end{align} \\] 我们可以再稍微简化一下，将这次线性变换表示为 \\[ \\begin{bmatrix} 2 &amp;&amp; 0 \\\\ 0 &amp;&amp; 2 \\end{bmatrix} \\] 左边一列为 \\(\\hat{i}\\) ，右边为 \\(\\vec{j}\\)，学过线性代数的童鞋可能一眼就发现了，这不就是矩阵吗？没错，但是更妙的还在后面，我们还可以套上矩阵的乘法来表示向量变换后的结果以及复合线性变换，例如对于下面的向量 \\[ \\begin{align} \\vec{v} = \\begin{bmatrix} 3 \\\\ 2 \\end{bmatrix} \\end{align} \\] 我们对其进行如上的线性变换，可以得到变换后的结果为 \\[ \\begin{align} \\vec{v&#39;} &amp;= f(\\vec{v}) \\\\\\\\ &amp;= \\begin{bmatrix} \\vec{i&#39;} &amp;&amp; \\vec{j&#39;} \\\\ \\end{bmatrix} \\begin{bmatrix} 3 \\\\ 2 \\end{bmatrix} \\\\\\\\ &amp;= \\begin{bmatrix} 2 &amp;&amp; 0 \\\\ 0 &amp;&amp; 2 \\end{bmatrix} \\begin{bmatrix} 3 \\\\ 2 \\end{bmatrix} \\\\\\\\ &amp;= 3 \\cdot \\begin{bmatrix} 2 \\\\ 0 \\end{bmatrix} + 2 \\cdot \\begin{bmatrix} 0 \\\\ 2 \\end{bmatrix} \\\\\\\\ &amp;= \\begin{bmatrix} 3 \\cdot 2 + 2 \\cdot 0 \\\\ 3 \\cdot 0 + 2 \\cdot 2 \\end{bmatrix} \\\\\\\\ &amp;= \\begin{bmatrix} 6 \\\\ 4 \\end{bmatrix} \\end{align} \\] 那么到这里我们就明白了以下几点： 线性变换的性质 线性变换的表示方式 对于向量的线性变换运算方式 复合变换 复合变换就是线性变换的组合，例如我们有两个线性变换 \\(f, g\\)，则它们的复合就是 \\[ f(g(\\vec{v})) \\] 复合变换的结果仍然是一个等价的变换，还是上面那个例子，对一个向量做 g, f 变换以后，可以等价为对这个向量做 h 变换 \\[ h(\\vec{v}) = f(g(\\vec{v})) \\] 例如下面这两张图中，一个是先后进行了两次变换，另一个是只进行了一次变换，但是它们的结果是相同的 先是旋转，再进行缩放 一次复合变换 那么，我们有办法计算多个线性变换复合后的等价线性变换吗？答案当然是有的 假定我们有以下两个线性变换： \\[ \\begin{align} f &amp;= \\begin{bmatrix} 2 &amp;&amp; 0 \\\\ 0 &amp;&amp; 2 \\end{bmatrix} \\\\\\\\ g &amp;= \\begin{bmatrix} \\cos(\\frac{\\pi}{3}) &amp;&amp; sin(\\frac{\\pi}{3}) \\\\ -\\sin(\\frac{\\pi}{3}) &amp;&amp; cos(\\frac{\\pi}{3}) \\end{bmatrix} \\end{align} \\] 容易看出来 f 将向量缩放为原来的两倍，g 为顺时针旋转 60°，当我们对一个向量执行 \\(f(g(\\vec{v}))\\) 的操作时，其等价的线性变换是什么？ 其实我们直接利用矩阵的乘法，将两个矩阵相乘就可以得到结果 \\[ \\begin{align} h &amp;= \\begin{bmatrix} 2 &amp;&amp; 0 \\\\ 0 &amp;&amp; 2 \\end{bmatrix} \\begin{bmatrix} \\cos(\\frac{\\pi}{3}) &amp;&amp; sin(\\frac{\\pi}{3}) \\\\ -\\sin(\\frac{\\pi}{3}) &amp;&amp; cos(\\frac{\\pi}{3}) \\end{bmatrix} \\\\\\\\ &amp;= \\begin{bmatrix} \\begin{bmatrix} 2 &amp;&amp; 0 \\\\ 0 &amp;&amp; 2 \\end{bmatrix} \\begin{bmatrix} \\frac{1}{2} \\\\ -\\frac{\\sqrt{3}}{2} \\end{bmatrix} &amp;&amp; \\begin{bmatrix} 2 &amp;&amp; 0 \\\\ 0 &amp;&amp; 2 \\end{bmatrix} \\begin{bmatrix} \\frac{\\sqrt{3}}{2} \\\\ \\frac{1}{2} \\end{bmatrix} \\end{bmatrix} \\\\\\\\ &amp;= \\begin{bmatrix} 1 &amp;&amp; \\sqrt{3}\\\\ -\\sqrt{3} &amp;&amp; 1 \\end{bmatrix} \\end{align} \\] 这里具体的公式不重要，重要的是我们怎么理解这个公式，或者说这个公式为什么逻辑上讲得通，我们对这个运算过程进行一个抽象 在经过 g 变换以后，原来的 \\(\\vec{i} \\rightarrow \\vec{i&#39;}\\)，\\(\\vec{j} \\rightarrow \\vec{j&#39;}\\) \\[ \\begin{align} g = \\begin{bmatrix} \\vec{i&#39;} &amp;&amp; \\vec{j&#39;} \\end{bmatrix} \\end{align} \\] 那么我们再次进行 f 变换，就相当于对 g 变换后的基向量进行了再一次变换，即 \\(\\vec{i&#39;} \\rightarrow \\vec{i&#39;&#39;}\\)，\\(\\vec{j&#39;} \\rightarrow \\vec{j&#39;&#39;}\\)，得到的 \\(\\vec{i&#39;&#39;}, \\vec{j&#39;&#39;}\\) 就是我们最终变换后的结果 \\[ \\begin{align} \\vec{i&#39;&#39;} &amp;= \\begin{bmatrix} 2 &amp;&amp; 0 \\\\ 0 &amp;&amp; 2 \\end{bmatrix} \\begin{bmatrix} \\frac{1}{2} \\\\ -\\frac{\\sqrt{3}}{2} \\end{bmatrix} \\\\ \\vec{j&#39;&#39;} &amp;= \\begin{bmatrix} 2 &amp;&amp; 0 \\\\ 0 &amp;&amp; 2 \\end{bmatrix} \\begin{bmatrix} \\frac{\\sqrt{3}}{2} \\\\ \\frac{1}{2} \\end{bmatrix} \\\\ h &amp;= \\begin{bmatrix} 1 &amp;&amp; \\sqrt{3}\\\\ -\\sqrt{3} &amp;&amp; 1 \\end{bmatrix} \\end{align} \\] 逆变换 理解了上面的复合变换，逆变换就很好理解了，逆变换就是一个线性变换的逆。当我们先进行了一次线性变换以后，再进行另一次线性变换以后，如果向量和进行线性变换之前相同，那么就说这两次线性变换互逆 例如对于下面的线性变换 \\[ A = \\begin{bmatrix} 2 &amp;&amp; 0 \\\\ 0 &amp;&amp; 2 \\end{bmatrix} \\] 我们很容易想到它的逆为 \\[ A^{-1} = \\begin{bmatrix} \\frac{1}{2} &amp;&amp; 0 \\\\ 0 &amp;&amp; \\frac{1}{2} \\end{bmatrix} \\] 我们将这两次线性变换进行组合，得到的结果为 \\[ AA^{-1} = \\begin{bmatrix} 1 &amp;&amp; 0 \\\\ 0 &amp;&amp; 1 \\end{bmatrix} \\] 这个结果就是 identity matrix，即不发生任何变换的线性变换 我们也可以用以下的公式计算出一个矩阵的逆 \\[ \\begin{bmatrix} a &amp;&amp; b \\\\ c &amp;&amp; d \\end{bmatrix} ^{-1} = \\frac{1}{ad-bc} \\begin{bmatrix} d &amp;&amp; -b \\\\ -c &amp;&amp; a \\end{bmatrix} \\] 坐标系的相互转换 上面我们说的基向量的选择是根据我们在笛卡尔坐标系下的约定俗成的基向量，但是我们完全也可以不选择 \\(\\hat{i}\\) 和 \\(\\hat{j}\\) 作为基向量，而是在空间中另外选择任意两个线性不相关的向量 \\(\\hat{u}\\), \\(\\hat{v}\\) 作为基向量，其他向量由这两个向量的线性组合得到 我们假定这两个基向量的值为 \\[ \\begin{align} \\vec{u} = \\begin{bmatrix} 0.6 \\\\ 0.4 \\end{bmatrix} \\\\ \\vec{v} = \\begin{bmatrix} 0.4 \\\\ -1 \\end{bmatrix} \\end{align} \\] 从下面的图里我们可以看到这两组基向量在笛卡尔坐标系下的展示 既然可以使用不同的基向量去表示某一向量，那么问题来了，对于空间中的同一个向量，我们怎么从一个坐标系表示转换到另一个坐标系表示? 例如上图中的 \\(\\vec{a}\\)，我们可以用两种方式表示它 \\[ \\begin{align} \\vec{a} &amp;= \\vec{u} + \\vec{v} \\\\ \\vec{a} &amp;= \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} \\\\\\\\ or \\space \\space \\vec{a} &amp;= \\vec{i} + (-0.6) \\vec{j} \\\\ \\vec{a} &amp;= \\begin{bmatrix} 1 \\\\ -0.6 \\end{bmatrix} \\end{align} \\] 但是到底怎么算出来呢？ 其实按照我自己的经验来看，要理解坐标系转换这件事还挺反直觉的，就像十进制和二进制之间的转换一样，我们早已习惯了在十进制下的运算，所以二进制转十进制比较方便，但是一旦反过来，我们就比较难理解其原理，或者换种说法就是很难掰过来自己的惯性思维 🤣 这里提供一个简单的思路，我们先去理解 如何将非标准坐标系下的向量表示转换为标准坐标系下的向量表示 要解决这个问题，我们只需要知道非标准坐标系下的 \\(\\hat{u}\\) 和 \\(\\hat{v}\\) 向量在标准坐标系下的表示是什么即可，例如对于上面的 \\(\\vec{a}\\)，我们知道它在非标准坐标系下的表示为 \\({1\\brack 1}\\)，那么我们就可以将其转化为: \\[ \\begin{align} \\vec{a} &amp;= 1\\vec{u} + 1\\vec{v} \\\\\\\\ &amp;= 1 \\begin{bmatrix} 0.6 \\\\ 0.4 \\end{bmatrix} + 1 \\begin{bmatrix} 0.4 \\\\ -1 \\end{bmatrix} \\\\\\\\ &amp;= \\begin{bmatrix} 0.6 + 0.4 \\\\ 0.4 - 1 \\end{bmatrix} \\\\\\\\ &amp;= \\begin{bmatrix} 1 \\\\ -0.6 \\end{bmatrix} \\end{align} \\] 这个很好理解，因为就是将非标准坐标系下的基准向量理解为笛卡尔坐标系下的一组普通向量，然后得到这组向量的对应线性组合就行 我们也可以将上述的过程表示为 \\[ \\begin{align} \\vec{a} &amp;= \\begin{bmatrix} 0.6 &amp;&amp; 0.4\\\\ 0.4 &amp;&amp; -1 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} \\\\\\\\ &amp;= \\begin{bmatrix} 1 \\\\ -0.6 \\end{bmatrix} \\end{align} \\] 这里的核心就是两个坐标系的基准向量之间的相互转换，从非标准到标准的转换就是把 \\(\\vec{u}\\) 和 \\(\\vec{v}\\) 为 \\(\\vec{i}\\) 和 \\(\\vec{j}\\) 表示 反过来也成立，从标准坐标系到非标准坐标系就是将 \\(\\vec{i}\\) 和 \\(\\vec{j}\\) 转为 \\(\\vec{u}\\) 和 \\(\\vec{v}\\)，那么我们就可以得到 \\(\\vec{a}\\) 在非标准坐标系下的表示为 \\[ \\begin{align} \\vec{a} &amp;= \\begin{bmatrix} 0.6 &amp;&amp; 0.4 \\\\ 0.4 &amp;&amp; 1 \\end{bmatrix} ^{-1} \\begin{bmatrix} 1 \\\\ -0.6 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} \\end{align} \\] 这样我们就可以得到一个公式，假设标准坐标系 \\(s\\) 到非标准坐标系 \\(n\\) 的线性变换为 \\(A\\)，那么： 非标准 -&gt; 标准 \\[ \\begin{align} \\vec{v} = A\\begin{bmatrix} x_{n} \\\\ y_{n} \\end{bmatrix} \\end{align} \\] 标准 -&gt; 非标准 \\[ \\begin{align} \\vec{v} = A^{-1}\\begin{bmatrix} x_{s} \\\\ y_{s} \\end{bmatrix} \\end{align} \\] 到这里线性代数的基本知识就告一段落了，里面还有很多内容本篇没涉及到，例如行列式(determinant)，特征值(eigenvalue)，特征向量(eigenvector), 向量内积外积，线性方程组 等，这些都是线代中的很重要的概念，但是由于篇幅原因，以及我们具体的使用场景限制，关于线性代数的内容就介绍到这里，读者如果想深入理解变换请务必严肃学习！","categories":[{"name":"Dive into Transformation","slug":"Dive-into-Transformation","permalink":"https://floribunda1.github.io/categories/Dive-into-Transformation/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://floribunda1.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"图形学","slug":"图形学","permalink":"https://floribunda1.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"前端","slug":"前端","permalink":"https://floribunda1.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"一个新的开始","slug":"一个新的开始","date":"2022-03-19T13:17:02.730Z","updated":"2022-05-17T02:56:20.783Z","comments":true,"path":"2022/03/19/一个新的开始/","link":"","permalink":"https://floribunda1.github.io/2022/03/19/%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/","excerpt":"","text":"其实写博客这个想法很久之前就有了，也曾经尝试过去写一些，最后都没有办法达到自己满意的效果 想了想原因，还是因为自己把写博客这件事情看的太重了，希望自己能输出一些有价值，深度的文章，哪怕是在学习新技术的过程中或者对自己之前做的事情的复盘，都希望自己能认真写，写好。然而最后都是因为自己的完美主义作祟，达不到自己想要的效果，又把这些文章删了 随着后来的踩坑和成长，逐渐意识到这样不好，世界并非是非黑即白的。现在想想我写博客一方面是记录自己的学习成长过程，倒逼自己的输出，另一方面是以后回过头来看看自己，发现这段时间并没有荒废，哪怕自己走了很多的弯路，也能意识到自己当时努力了，那样就好 希望以后能长更博客，不管是 cheatsheet，还是一些学习笔记，还是自己的一些牢骚或者想法。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://floribunda1.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://floribunda1.github.io/tags/%E6%9D%82%E8%B0%88/"}]}],"categories":[{"name":"Dive into Transformation","slug":"Dive-into-Transformation","permalink":"https://floribunda1.github.io/categories/Dive-into-Transformation/"},{"name":"杂谈","slug":"杂谈","permalink":"https://floribunda1.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://floribunda1.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"图形学","slug":"图形学","permalink":"https://floribunda1.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"前端","slug":"前端","permalink":"https://floribunda1.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"杂谈","slug":"杂谈","permalink":"https://floribunda1.github.io/tags/%E6%9D%82%E8%B0%88/"}]}